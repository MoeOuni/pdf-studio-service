# "org" ensures this Service is used with the correct Serverless Framework Access Key.
org: ounitek
# "app" enables Serverless Framework Dashboard features and sharing them with other Services.
app: pdf-studio-service
# "service" is the name of this project. This will also be added to your AWS resource names.
service: pdf-studio-api

frameworkVersion: '3'

# Provider configuration
provider:
  name: aws
  runtime: nodejs20.x
  stage: ${opt:stage, 'dev'}
  region: ${opt:region, 'us-east-1'}
  
  # Global environment variables
  environment:
    STAGE: ${self:provider.stage}
    REGION: ${self:provider.region}
    
    # DynamoDB
    DYNAMODB_TABLE: ${self:service}-${self:provider.stage}
    
    # PostgreSQL (RDS)
    DATABASE_URL: 
      Fn::Sub: 
        - postgresql://${Username}:${Password}@${Endpoint}:5432/${DatabaseName}?schema=public
        - Username: ${self:custom.database.username}
          Password: ${self:custom.database.password}
          Endpoint: !GetAtt PostgreSQLInstance.Endpoint.Address
          DatabaseName: ${self:custom.database.name}
    DB_NAME: ${self:custom.database.name}
    DB_USER: ${self:custom.database.username}
    DB_PASSWORD: ${self:custom.database.password}
    
    # S3
    S3_BUCKET: ${self:service}-${self:provider.stage}
    
  # Global function defaults
  timeout: 30
  memorySize: 256
  
  # Tracing and monitoring
  tracing:
    lambda: true
    apiGateway: true
    
  # Logs retention
  logs:
    httpApi: true
    
  # IAM permissions - imported from separate file
  iam:
    role:
      statements: ${file(infrastructure/iam/lambda-execution-role.yml):iamRoleStatements}

# Plugins
plugins:
  - serverless-esbuild
  - serverless-offline
  - serverless-dynamodb

# Package configuration
package:
  patterns:
    - '!node_modules/**'

# Custom configuration
custom:
  # Database configuration per stage
  database:
    name: pdf_studio_${self:provider.stage}
    username: pdf_studio_user
    password: ${env:DB_PASSWORD, 'changeme123!'}
  
  # VPC configuration - you can customize per environment
  vpc:
    dev: vpc-0c9ea7b37f96a8092      # Default VPC for dev (working)
    staging: vpc-0c9ea7b37f96a8092   # Change this when you have staging VPC
    prod: vpc-0c9ea7b37f96a8092      # Change this when you have production VPC
    
  # Database configuration per stage
  databaseUrl:
    dev: postgresql://${self:custom.database.username}:${self:custom.database.password}@${env:RDS_ENDPOINT, 'localhost'}:5432/${self:custom.database.name}?schema=public
    staging: postgresql://${self:custom.database.username}:${self:custom.database.password}@${env:RDS_ENDPOINT, 'localhost'}:5432/${self:custom.database.name}?schema=public
    prod: postgresql://${self:custom.database.username}:${self:custom.database.password}@${env:RDS_ENDPOINT, 'localhost'}:5432/${self:custom.database.name}?schema=public
  
  # Deployment bucket for layers
  deploymentBucket: ${self:service}-deployments-${self:provider.stage}
  
  # ESBuild configuration for TypeScript compilation
  esbuild:
    bundle: true
    minify: false  # Keep readable for debugging
    sourcemap: false  # Disable sourcemaps for smaller bundles
    exclude: 
      - 'aws-sdk'
      - 'mock-aws-s3' 
      - 'nock'
    target: 'node20'
    define:
      'require.resolve': undefined
      'process.env.NODE_ENV': '"production"'
    external: 
      - 'aws-sdk'
      - 'mock-aws-s3'
      - 'nock'
    loader:
      '.html': 'text'
    platform: 'node'
    concurrency: 10
    keepNames: true  # Keep function names for debugging
    treeShaking: false  # Disable for compatibility
    format: 'cjs'
    mainFields: ['main', 'module']
    conditions: ['node']
    
  # Serverless offline configuration for local development
  serverless-offline:
    httpPort: 3000
    babelOptions:
      presets: ["env"]
    printOutput: true
    
  # DynamoDB local configuration
  dynamodb:
    start:
      port: 8000
      inMemory: true
      migrate: true
    stages:
      - dev

# Functions - imported from modular configurations
# Individual function configurations are maintained in their respective module folders
# The functions.js file is compiled from functions.ts with full TypeScript support
functions: ${file(infrastructure/functions.js)}

# Import resources from separate files
resources:
  # PostgreSQL RDS
  - ${file(infrastructure/resources/rds.yml)}
  
  # DynamoDB resources
  - ${file(infrastructure/resources/dynamodb.yml)}
  
  # S3 resources
  - ${file(infrastructure/resources/s3.yml)}
  
  # Lambda layers (commented out for now)
  # - ${file(infrastructure/layers/shared-layer.yml)}
